
/*******************************************************************************
    Verilog netlist generated by IPGEN Lattice Radiant Software (64-bit)
    2023.1.1.200.1
    Soft IP Version: 2.0.0
    2025 01 20 09:42:39
*******************************************************************************/
/*******************************************************************************
    Wrapper Module generated per user settings.
*******************************************************************************/
module count (clk_i, 
        clk_en_i, 
        aclr_i, 
        q_o) ;
    input clk_i ; 
    input clk_en_i ; 
    input aclr_i ; 
    output [7:0] q_o ; 
    count_ipgen_lscc_cntr #(.CNTR_WIDTH(8),
            .CNTR_DIR(1),
            .CNTR_LVALUE(0),
            .CNTR_HVALUE(255),
            .CNTR_LOAD(0),
            .FAMILY("iCE40UP")) lscc_cntr_inst (.clk_i(clk_i), 
                .clk_en_i(clk_en_i), 
                .aclr_i(aclr_i), 
                .updown_i(1'b0), 
                .load_i(1'b0), 
                .ldata_i(8'b00000000), 
                .q_o(q_o[7:0])) ; 
endmodule



// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2018 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : 
// File                  : lscc_cntr.v
// Title                 : 
// Dependencies          : 
// Description           : An Up, Down and Up-Down counter that counts  
//                       : a step of 1 per clock. 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
module count_ipgen_lscc_cntr (// -----------------------------------------------------------------------------
    // Ports
    // -----------------------------------------------------------------------------
    // ----- Clocks-Resets -----
    clk_i, 
        clk_en_i, 
        aclr_i, 
        // ----- Counter IOs -----
    updown_i, 
        load_i, 
        ldata_i, 
        q_o) ;
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    parameter integer CNTR_WIDTH = 8 ; 
    parameter [1:0] CNTR_DIR = 2'b01 ; 
    localparam integer CNTR_WDT = ((CNTR_WIDTH < 2) ? 2 : CNTR_WIDTH) ; 
    parameter [(CNTR_WDT - 1):0] CNTR_LVALUE = {CNTR_WDT{1'b0}} ; 
    parameter [(CNTR_WDT - 1):0] CNTR_HVALUE = {CNTR_WDT{1'b1}} ; 
    parameter CNTR_LOAD = 0 ; 
    parameter FAMILY = "LIFCL" ; 
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam [0:0] HVAL_EQ_0 = (CNTR_HVALUE == {CNTR_WDT{1'b0}}) ; 
    localparam [0:0] HVAL_LE_LVAL = (CNTR_HVALUE <= CNTR_LVALUE) ; 
    localparam [(CNTR_WDT - 1):0] CNTR_HVAL = (HVAL_EQ_0 ? 1 : CNTR_HVALUE) ; 
    localparam [(CNTR_WDT - 1):0] CNTR_LVAL = (HVAL_LE_LVAL ? (CNTR_HVALUE - 1) : CNTR_LVALUE) ; 
    localparam [(CNTR_WDT - 1):0] CNTR_STEP = 1 ; 
    // -----------------------------------------------------------------------------
    // Declared Input/Output Ports
    // -----------------------------------------------------------------------------
    // ----- Clocks-Resets -----
    input clk_i ; 
    input clk_en_i ; 
    input aclr_i ; 
    // ----- Counter IOs -----
    input updown_i ; 
    input load_i ; 
    input [(CNTR_WDT - 1):0] ldata_i ; 
    output reg [(CNTR_WDT - 1):0] q_o ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire UpDown_w = (CNTR_DIR[1] ? updown_i : CNTR_DIR[0]) ; 
    wire lwrap = (q_o <= CNTR_LVAL) ; 
    wire hwrap = (q_o >= CNTR_HVAL) ; 
    // -----------------------------------------------------------------------------
    // Sequential Block
    // -----------------------------------------------------------------------------
    always
        @(posedge clk_i or 
            posedge aclr_i)
        begin
            if (aclr_i) 
                q_o <=  CNTR_LVAL ;
            else
                if ((!clk_en_i)) 
                    q_o <=  q_o ;
                else
                    if (load_i) 
                        q_o <=  ldata_i ;
                    else
                        if (UpDown_w) 
                            q_o <=  (hwrap ? CNTR_LVAL : {(q_o + CNTR_STEP)}) ;
                        else
                            q_o <=  (lwrap ? CNTR_HVAL : {(q_o - CNTR_STEP)}) ;
        end
endmodule


